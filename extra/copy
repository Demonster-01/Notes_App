from fastapi import FastAPI, HTTPException, Depends, status
from pydantic import BaseModel
from typing import Annotated
import models
from database import engine, SessionLocal
from sqlalchemy.orm import session

app=FastAPI()
models.Base.metadata.create_all(bind=engine)


class PostBase(BaseModel):
    title:str
    content:str
    user_id:int


class UserBase(BaseModel):
    username:str

def get_db():
    db=SessionLocal()
    try:
        yield db
    finally:
        db.close()

db_dependency=Annotated[session,Depends(get_db)]

@app.post("/post/",status_code=status.HTTP_201_CREATED)
async def create_post(post:PostBase, db:db_dependency):
    db_post=models.Post(**post.dict())
    db.add(db_post)
    db.commit()


# @app.post("/post/", status_code=status.HTTP_201_CREATED)
# async def create_post(post: PostBase, db: session = Depends(get_db)):
#     db_post = models.Post(**post.dict())
#     db.add(db_post)
#     db.commit()
#     db.refresh(db_post)
#     return db_post


@app.get("/posts/{post_id}",status_code=status.HTTP_200_OK)
async def read_post(post_id:int,db:db_dependency):
    post=db.query(models.Post).filter(models.Post.id==post_id).first()
    if post is None:
        raise HTTPException(status_code=404,detail="Post not found")
    return post



@app.post("/users/",status_code=status.HTTP_201_CREATED)
async def create_user(user:UserBase,db:db_dependency):
    db_user=models.User(**user.dict())
    db.add(db_user)
    db.commit()

@app.get("/users/{user_id}",status_code=status.HTTP_200_OK)
async def read_user(user_id:int, db:db_dependency):
    user=db.query(models.User).filter(models.User.id==user_id).first()
    if user is None:
         raise HTTPException(status_code=404,detail="User not found")
    return user

@app.delete("/posts/{post_id}",status_code=status.HTTP_200_OK)
async def delete_post(post_id:int,db:db_dependency):
    db_post=db.query(models.Post).filter(models.Post.id==post_id).first()
    if db_post is None:
        raise HTTPException(status_code=404,detail="Post was not found")
    db.delete(db_post)
    db.commit()


@app.get("/papers", response_model=List[PaperBase], status_code=status.HTTP_200_OK)
async def get_papers_by_semester_type(semester: Optional[str] = Query(None),
                                      paper_type: Optional[str] = Query(None),
                                      db: Session = Depends(get_db)):
    query = db.query(Paper)

    if semester:
        query = query.filter(Paper.semester == semester)
    if paper_type:
        query = query.filter(Paper.paper_type == paper_type)

    papers = query.all()
    if not papers:
        raise HTTPException(status_code=404, detail="Data not found")

    return papers


    # @app.post("/login", status_code=status.HTTP_200_OK)
# async def login(request: Request,
#                 username: str = Form(...),
#                 password: str = Form(...),
#                 db: Session = Depends(get_db)):
#     print("password:", password)
#
#     user = db.query(models.UserRegister).filter(models.UserRegister.username == username).first()
#     print("password:", user)
#     if not user:
#         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid username or password")
#     if user.password != password:
#         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid username or password")
#     return {"message": "Login successful", "user": user.username}


    # if not verify_password(password, user.password):
    #     raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid username or password")